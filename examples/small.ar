// immutable with runtime known
// immutable with compile time known
// mutable with rumtime known
// mutable with compile time known

//imm x = {yield 1;};

impl ToString.cool for *Main<T> {
    fn cool() void {}
}

//fn main2() void {}

impl usize {}

struct ff {
    Vec: gg,
}

struct Main {
    //buf: cool,
    buf2: *u32,
    buf3: [2](u8),
}

imm cool: ff = undefined;

imm primes: gg = {
    imm sum = {
        yield [0, 1, 2, 3, 4];
    };
    imm sum = .();
    imm sum = .(1, 2, 3);
    imm newliteral = Player {
        .pos = 1,
        .vel = oldvel(),
    };
    yield .(sum);
};

imm voidd: void = undefined;

struct gg { po: fn (i32) i32 }

//imm primes = [1, 2, 3];

fn add(a: *imm void, b: *imm void, c: *imm void) void {}

fn main() void {
    fn cool(a: int, b: int) std.Vec<usize, u8, *std.Vec<u8>> {
        fn cool() df {cool;}
        mut name = cool(a,cool(),mutable({}, {fn cool() void {}}));
        mut place = Vec::<u32>.new();
        imm war = if (cool) {call();} else cool;
        {mut name = {cool;};}
        if (main) {} else if (main) {} else if (main) {}

        if (main) {
            if (cool.a.b) 1 else {}
        }
        voidd(1, My.Player::<u32>.newtype {.name = 1}, 2, New {.f = 1});
        add(1, 1, 1, 1, 1, 1);
        return @import(1).a;
        yield 1;
    }
}

// imm ptr: *fn (i32) i32 = 0x3423432;
// ptr();

struct Cool {
    a: *i64,
    b: *u8,
}
